pragma nexscript >= 0.2.0;

/*******************************************************************************
 *
 * Copyright (c) 2024 Ava's DAO
 * Released under the MIT License.
 *
 * Polymorph PoW (Proof-of-Work)
 *
 * A mutable proof-of-work (PoW) mining "wise" contract; specially designed for
 * hybrid operation in either self-running OR hosted mode, or a combination
 * of the two.
 *
 * NOTES
 * --------------------
 * The hybrid model offers the option of CPU & GPU modes of operation. Or
 * a alternating-mode which can switch back-and-forth.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Version     : 01
 * Script Hash : 0x0000000000000000000000000000000000000000
 * Namespace   : POLYPOW01
 *
 * algo       : A (dynamic) algorithm designed to ONLY be revealed AFTER submission. (MUST use a nonce when repeating algos)
 * assetid    : The Hash160 of the primary asset. (used for data analytics) [NOTE: This is the ONLY "visible" parameter.]
 * epoch      : Number of total blocks mined.
 * difficulty : Number of leading zeroes required to pass hashing challenge.
 * tribute    : A fixed amount (set by the Administrator) of each block reward is sent to the Treasury.
 * handicap   : Used to add additional "challenge" to the Public mining reward. (expected to a factor of GPU vs CPU)
 * guardian   : A hash used to verify the correct nonce.
 * admin      : The asset Administrator.
 * treasury   : Destination for all fees, set by the Administrator.
 * isPublic   : A "miner-set" flag used to designate the current mining status and enable/disable the Handicap.
 *
 * For more information, please visit the following resources:
 *   - https://nxy.cash
 *   - https://avasdao.org
 *
 * @param algo
 * @param assetid
 * @param epoch
 * @param difficulty
 * @param tribute
 * @param handicap
 * @param guardian
 * @param admin
 * @param treasury
 * @param isPublic
 *
 */
contract Polymorph(
    bytes20 visible unused algo, // NOTE: Used in "hack" to `OP_ROLL` dynamic (contract) hash verification.
    bytes20 visible assetid,
    int epoch,
    int difficulty,
    int tribute,
    int handicap,
    bytes20 guardian,
    bytes20 admin,
    bytes20 treasury,
    bool isPublic,
) {

    // contract Minter(
    //     bytes20 unused algo,
    //     bytes20 visible unused assetid,
    //     int epoch,
    //     int tribute,
    //     int handicap,
    //     bytes20 guardian,
    //     bytes20 admin,
    //     bytes20 treasury,
    //     bool isPublic,
    // ) {
    //     //
    // }

    /**
     * Mint
     *
     * Mint a NEW proof-of-work token, based on the rewards schedule.
     *
     * An (optional) access code can be used to offer additional protections
     * against malicious use and/or abuse of the Script template.
     *
     * NOTE: `access` (code) should be a random (up to 160-bit) value.
     *
     * NOTE: `miner` allows mining pools to operate w/out the concern
     *       that miners will be selfish with their solution candidates.
     *
     * @param access
     * @param miner
     * @param candidate
     */
    function mint(
        bytes20 access,
        bytes20 miner,
        bytes32 candidate,
    ) {
        /**
         * Initial Mining Rewards
         *
         * (measured in asset's atomic unit)
         *
         * Set initial mining rewards value.
         *
         * NOTE: This is hard-coded and CANNOT be changed EVER!!
         */
        int INITIAL_MINING_REWARDS = 5000000000;

        /**
         * Season Length
         *
         * (measured in blocks)
         *
         * Mining rewards will be adjusted at this interval.
         *
         * (2 minute blocks) x (24 hours) = 720 blocks
         *                   x (90 days)  = 64,800 blocks
         *                                = 1 season
         *
         * NOTE: Variance exists in relation to Nexa block generation.
         * NOTE: This is hard-coded and CANNOT be changed EVER!!
         */
        int SEASON_LENGTH = 64800;

        /* Set basis points (scaling factor). */
        int BASIS_POINTS = 10000;

        //----------------------------------------------------------------------
        // BEGIN CONTRACT SECURITY & PRESERVATION VERIFICATION
        //----------------------------------------------------------------------

        /* Verify UTXO age is AT LEAST ONE BLOCK. */
        // NOTE: Allows for mining (hash) attack mitigation (if required).
        require(tx.age >= 1);

        /* Verify (registered) asset id. */
        require(hash160(tx.outputs[this.activeInputIndex]
                .tokenGroupId) == assetid);

        /* Set locking bytes length. */
        int lockLen = tx.inputs[this.activeInputIndex]
            .lockingBytecode.length;

        /* Build "public" locking bytes. */
        // NOTE: `OP_TRUE` or `OP_1` is encoded as `0x51`.
        bytes publicLock = tx.inputs[this.activeInputIndex]
            .lockingBytecode.split(lockLen - 1)[0] + 0x51;

        /* Verify contract lock remains unchanged (except `public` flag). */
        // NOTE: Parameter updates are "managed" by the Manager.
        //       (see the Manager contract below)
        require(tx.outputs[this.activeInputIndex]
                .lockingBytecode == publicLock);

        // NOTE: Token (mint authority) value is preserved
        //       in the locking script.

        //----------------------------------------------------------------------
        // END CONTRACT SECURITY & PRESERVATION VERIFICATION
        //----------------------------------------------------------------------

        //----------------------------------------------------------------------
        // BEGIN MINING CHALLENGE VERIFICATION
        //----------------------------------------------------------------------

        /* Verify Guardian access code. */
        // NOTE: See the Wisebox Docs for more information about
        //       the use of Guardians.
        require(hash160(access) == guardian);

        /* Set entropy from the previous transaction hash. */
        bytes entropy = tx.inputs[this.activeInputIndex]
            .outpointTransactionHash;

        /**
         * Hashing Challenge
         *
         * Miner-submitted (solution) candidate is inserted into
         * the dynamically provided (Enclave-attested) hashing script.
         *
         * Three (3) parameters are concatenated together to evaluate
         * a potential block reward candidate:
         *   1. (Primary) miner script hash
         *   2. Entropy (from previous tx hash)
         *   3. Miner (solution) candidate
         *   (i.e. scriptHash + entropy + candidate)
         *
         * The Polymorph Hashing Engine utilizes five (5) hashing algorithms
         * when generating random challenges:
         *   ✔ SHA-1
         *   ✔ RIPEMD-160
         *   ✔ SHA-256
         *   ✔ SHA-256(RIPEMD-160)
         *   ✔ SHA-256(SHA-256)
         *
         * NOTE: Do to the current Op code limit and Script size,
         *       there is a maximum of ten (10) random hashes allowed.
         *
         * !! IMPORTANT COMPILER NOTE !!
         * In order to enable the Polymorph Hashing Engine, contract
         * architect(s) are REQUIRED to *manually* adjust the NexScript
         * compiler automatically-generated Script (Op codes).
         *
         * They MUST utilize the `bytes20 unused algo` (placeholder) by
         * inserting an `OP_ROLL` into the Script, for the purpose of
         * *dynamically* replacing the hard-coded "contract verification hash"
         * inserted by the NexScript (nexc) compiler.
         */
        bytes solution = (
            hash256( // duplicated
                ripemd160( // duplicated
                    hash256(
                        hash160(
                            sha256(
                                ripemd160(
                                    sha1(miner + entropy + candidate)
                                )
                            )
                        )
                    )
                )
            )
        );

        /* Verify public difficulty. */
        if (isPublic) {
            /* Re-calculate difficulty for desktop/GPU miners. */
            // NOTE: A 256-bit solution has a maximum of (32) bytes.
            difficulty = min((difficulty * handicap), 32);
        }

        /* Generate a submission that meets the difficulty requirement. */
        // NOTE: Each `difficulty` represents one (1) byte OR two (2) zeroes,
        //       as we CANNOT cast <bytes> to <string>.
        bytes submission = solution.split(difficulty)[0];

        /* Verify the FINAL submission. */
        require(submission == 0x);

        //----------------------------------------------------------------------
        // END MINING CHALLENGE VERIFICATION
        //----------------------------------------------------------------------

        //----------------------------------------------------------------------
        // BEGIN MINING REWARD VERIFICATION
        //----------------------------------------------------------------------

        /* Calculate current season. */
        int currentSeason = (epoch / SEASON_LENGTH) + 1;

        /* Calculate Mining reward. */
        int miningReward = (INITIAL_MINING_REWARDS / currentSeason);

        /* Verify Mining (token) reward *exact* amount. */
        // NOTE: Verification is NOT for a single output, but for
        //       the TOTAL output amount of the FULL transaction.
        //       (especially convenient for mining pool payouts)
        // NOTE: Treasury Tribute is validated elsewhere.
        require(
            tx.groupAmountOut(bytes32(
                tx.inputs[this.activeInputIndex]
                    .tokenGroupId)) == miningReward
        );

        //----------------------------------------------------------------------
        // END MINING REWARD VERIFICATION
        //----------------------------------------------------------------------

        //----------------------------------------------------------------------
        // BEGIN TREASURY TRIBUTE VERIFICATION
        //----------------------------------------------------------------------

        /* Verify a Treasury Tribute. */
        // NOTE: If required, MUST be the 2nd output of the transaction.
        if (tribute > 0) {
            /* Calculate Treasury Tribute amount. */
            int tributeAmount = (miningReward * tribute) / BASIS_POINTS;

            /* Verfify Treasury Tribute amount. */
            require(tx.outputs[1].tokenAmount >= tributeAmount);

            /* Set locking (bytecode) length. */
            lockLen = tx.outputs[1].lockingBytecode.length;

            /* Verify Treasury (bytecode). */
            require(tx.outputs[1].lockingBytecode
                .split(lockLen - 20)[1] == treasury);
        }

        //----------------------------------------------------------------------
        // END TREASURY TRIBUTE VERIFICATION
        //----------------------------------------------------------------------
    }

    // contract Manager(
    //     bytes20 unused algo,
    //     bytes20 visible unused assetid,
    //     int unused epoch,
    //     int unused difficulty,
    //     int unused tribute,
    //     int unused handicap,
    //     bytes20 unused guardian,
    //     bytes20 unused admin,
    //     bytes20 unused treasury,
    //     bool unused isPublic,
    // ) {
    //     //
    // }

    /**
     * Manage
     *
     * Guards against unauthorized access to the Minting authority
     * of the primary asset.
     *
     * NOTE: The Persona (or other authority) MUST be linked to the
     *       2nd input of the transaction.
     */
    function manage() {
        /* Set authorized sub-group id. */
        bytes authorized = tx.inputs[1].tokenSubgroupId;

        /* Verify Admin authorization. */
        require(hash160(authorized) == admin);
    }

}
